'use strict';
const Datastore = require('@google-cloud/datastore'),
  fs = require('fs'),
  path = require('path'),
  decamelize = require('decamelize'),
  camelize = require('camelize'),
  camelCase = require('camelcase'),
  initModel = require('./storeModel');
/**
 * The Google CloudStore Thorin.js wrapper
 * */
module.exports = function (thorin, opt) {

  const config = Symbol(),
    store = Symbol(),
    logger = Symbol(),
    models = Symbol(),
    initialized = Symbol();
  let StoreModel;

  class ThorinGcloudStore extends thorin.Interface.Store {

    constructor() {
      super();
      this.type = 'gcloud';
      this[config] = {};
      this[logger] = null;
      this[models] = {};
      this[initialized] = false;
    }

    /**
     * Store configuration:
     *
     * config.credentials - the JSON content of a Google Service Account key, or the string path (Relative to thorin.root) of the file
     * config.namespace - the namespace to use (defaults to none)
     * config.path - the path for our models
     * */
    init(storeConfig) {
      this[config] = thorin.util.extend({
        credentials: null, // Google Cloud credentials json content
        namespace: '',
        projectId: null,
        idSize: 26, // the size of the "id" field
        path: path.normalize(thorin.root + '/app/entities')
      }, storeConfig);
      if (process.env.GOOGLE_APPLICATION_CREDENTIALS && (!this[config].credentials || (typeof this[config].credentials === 'object' && Object.keys(this[config].credentials).length === 0))) {
        this[config].credentials = process.env.GOOGLE_APPLICATION_CREDENTIALS;
      }
      if (!this[config].credentials) {
        throw thorin.error('STORE.GCLOUD', 'Missing or invalid credentials');
      }
      if (typeof this[config].credentials === 'string' && this[config].credentials) {
        this[config].credentials = this[config].credentials.trim();
        if (this[config].credentials.charAt(0) === '{') {
          try {
            this[config].credentials = JSON.parse(this[config].credentials);
          } catch (e) {
            throw thorin.error('STORE.GCLOUD', 'Credentials could not be parsed');
          }
        } else {
          let credPath = this[config].credentials.charAt(0) === '/' ? path.normalize(this[config].credentials) : path.normalize(thorin.root + '/' + this[config].credentials);
          try {
            let creds = fs.readFileSync(credPath, {encoding: 'utf8'});
            creds = JSON.parse(creds);
            this[config].credentials = creds;
          } catch (e) {
            throw thorin.error('STORE.GCLOUD', 'Credentials could not be read [' + credPath + ']');
          }
        }
      }
      StoreModel = initModel(thorin, this[config]);
      this[store] = new Datastore({
        namespace: this[config].namespace,
        credentials: this[config].credentials,
        projectId: this[config].projectId
      });
      if (this[config].path) {
        let files = thorin.util.readDirectory(this[config].path, {
          ext: '.js'
        });
        for (let i = 0, len = files.length; i < len; i++) {
          let file = files[i],
            code = path.basename(file).replace('.js', '');
          code = camelCase(code);
          let modelObj = new StoreModel(code),
            modelFn = require(file);
          if (typeof modelFn !== 'function') continue;
          modelFn(modelObj, StoreModel);
          if (!modelObj.isValid()) throw thorin.error('STORE.GCLOUD', `Store model ${modelObj.code} is not valid`);
          this[models][modelObj.code] = modelObj;
          modelObj.store = this;
        }
      }
      this[initialized] = true;
    }

    /**
     * Returns a registered model or null
     * */
    model(code) {
      if (typeof code !== 'string' || !code) return null;
      return this[models][code] || null;
    }

    /**
     * Raw saving of data
     * Example:  https://github.com/googleapis/nodejs-datastore/blob/master/samples/tasks.js
     * */
    async create(entity) {
      try {
        if (entity instanceof Array) {
          return await this[store].upsert(entity);
        }
        return await this[store].save(entity);
      } catch (e) {
        throw thorin.error('STORE.GCLOUD', 'An error occurred while saving entity', e);
      }
    }

    /**
     * Raw updating of data
     * */
    async update(entity) {
      try {
        if (entity instanceof Array) {
          return await this[store].upsert(entity);
        }
        return await this[store].update(entity);
      } catch (e) {
        throw thorin.error('STORE.GCLOUD', 'An error occurred while updating entity', e);
      }
    }

    /**
     * Destroys the given key generated by store.key()
     * */
    async destroy(key) {
      try {
        let res = await this[store].delete(key);
        res = res[0];
        return res;
      } catch (e) {
        throw thorin.error('STORE.GCLOUD', 'An error occurred while deleting entity', e);
      }
    }

    /**
     * Creates a datastore query object
     * */
    createQuery(code, id) {
      if (code instanceof StoreModel) {
        code = this.key(code, id).path;
      }
      return this[store].createQuery(code);
    }

    /**
     * Perform a raw query using the provided createQuery() query
     * */
    async query(qry, opt) {
      try {
        if (typeof qry.run !== 'function') {
          throw thorin.error('STORE.GCLOUD', `query() requires a QueryObject as its first parameter`);
        }
        let res = await this[store].runQuery(qry, opt);
        return res;
      } catch (e) {
        throw thorin.error(`STORE.GCLOUD`, `An error occurred while querying store`, e);
      }
    }

    /**
     * Generates a key based on the given entity types
     * */
    key(kind, name) {
      if (kind instanceof StoreModel) {
        let arg = [];
        if (kind.parent) arg.push(kind.parent);
        arg.push(kind.code);
        if (name) arg.push(name); // acts as an ID
        return this[store].key(arg);
      }
      if (kind instanceof Array) {
        return this[store].key(kind);
      }
      return this[store].key([kind, name]);
    }


    /**
     * Registers a model in the store.
     * */
    addModel(modelObj) {
      if (!(modelObj instanceof StoreModel)) {
        throw thorin.error('STORE.GCLOUD', `Model is not of type StoreModel`);
      }
      if (this[models][modelObj.code]) {
        throw thorin.error('STORE.GCLOUD', `Model ${modelObj.code} is already registered`);
      }
      this[models] = modelObj;
      modelObj.store = this;
      return this;
    }


    /**
     * Initialize the ping request only if we have not before.
     * */
    async ping() {
      let res = await this[store].get(this.key('Root', 'Ping'));
      return true;
    }

    setup(done) {
      // TODO
      done();
    }

    async run(done) {
      for (let m in this.models) {
        this.models[m].store = this[store];
      }
      try {
        let sha = thorin.util.sha1(JSON.stringify(this[config].credentials));
        let checked = thorin.persist('store_gcloud_data');
        if (typeof checked === 'object' && checked && checked.sha === sha) {
          return done();
        }
        await this.ping();
        thorin.persist('store_gcloud_data', {
          sha
        });
        done();
      } catch (e) {
        done(thorin.error('STORE.GCLOUD', 'Could not verify Google Cloudstore credentials', e));
      }
    }

    get logger() {
      if (!this[logger]) return thorin.logger('store.' + this.type);
      return this[logger];
    }

    static publicName() {
      return "gcloud";
    }
  }

  /* Expose our Model */
  ThorinGcloudStore.Model = StoreModel;

  return ThorinGcloudStore;
}